<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>2048 ‚Äî Fixed</title>
<style>
  :root {
    --gap: 12px;
    --radius: 12px;
    --board-bg: #bbada0;
    --cell-bg: rgba(238, 228, 218, 0.35);
    --page-bg: radial-gradient(1200px 800px at 50% -10%, #0a1a26 0%, #070e16 60%, #04080d 100%);
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    color: #e8e8e8;
    background: var(--page-bg);
    font: 600 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial;
    display: grid;
    place-items: center;
    padding: 18px;
  }
  .wrap { width: min(96vw, 520px); }
  .topbar {
    display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap;
    margin-bottom: 12px;
  }
  .brand { font-size: 20px; font-weight: 900; letter-spacing: .02em; }
  .scores { display: flex; gap: 8px; }
  .badge {
    background: rgba(0,0,0,.35);
    border: 1px solid rgba(255,255,255,.15);
    padding: 6px 10px;
    border-radius: 10px;
    min-width: 90px;
    text-align: center;
    font-weight: 800;
  }
  .badge b { display: block; color: #ffd54f; font-size: 18px; margin-top: 2px; }
  .controls {
    display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 10px;
  }
  button, select {
    background: rgba(255,255,255,.08);
    color: #fff; border: 1px solid rgba(255,255,255,.15);
    border-radius: 10px; padding: 8px 12px;
    font-weight: 800; cursor: pointer;
    backdrop-filter: blur(6px);
  }
  button:hover { background: rgba(255,255,255,.12); }
  button:active { transform: translateY(1px); }
  .hint { opacity: .8; margin: 6px 0 10px; }

  .board {
    position: relative;
    width: 100%;
    aspect-ratio: 1/1;
    background: var(--board-bg);
    border-radius: calc(var(--radius) + 4px);
    padding: var(--gap);
    user-select: none;
    touch-action: none;
    box-shadow: 0 20px 60px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.06);
  }
  .grid, .tiles { position: absolute; inset: var(--gap); }
  .grid {
    display: grid;
    grid-template-columns: repeat(var(--size), 1fr);
    grid-auto-rows: 1fr;
    gap: var(--gap);
    height: 100%;
  }
  .cell {
    background: var(--cell-bg);
    border-radius: var(--radius);
  }
  .tiles { pointer-events: none; }

  .tile {
    position: absolute;
    border-radius: var(--radius);
    display: grid; place-items: center;
    font-weight: 900;
    transition: transform 120ms ease-in;
    will-change: transform;
    box-shadow: inset 0 0 0 1px rgba(0,0,0,.04);
    transform: translate(var(--tx, 0), var(--ty, 0)) scale(var(--s,1));
  }
  .tile.bump { animation: bump 120ms ease-out; }
  @keyframes bump {
    0% { transform: translate(var(--tx), var(--ty)) scale(1); }
    50% { transform: translate(var(--tx), var(--ty)) scale(1.12); }
    100% { transform: translate(var(--tx), var(--ty)) scale(1); }
  }

  .overlay {
    position: absolute; inset: 0;
    display: none; place-items: center;
    background: rgba(0,0,0,.45);
    border-radius: calc(var(--radius) + 4px);
    backdrop-filter: blur(4px);
  }
  .overlay.show { display: grid; }
  .panel {
    background: rgba(0,0,0,.55);
    border: 1px solid rgba(255,255,255,.15);
    padding: 14px 16px;
    border-radius: 12px;
    text-align: center;
    font-weight: 800;
    min-width: 60%;
  }
  .panel .title { font-size: 20px; margin-bottom: 6px; }
  .panel .row { margin-top: 8px; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">2048</div>
      <div class="scores">
        <div class="badge">Score<b id="score">0</b></div>
        <div class="badge">Best<b id="best">0</b></div>
      </div>
    </div>

    <div class="controls">
      <button id="newGame">New Game</button>
      <button id="undo">Undo</button>
      <label>Size:
        <select id="sizeSel">
          <option>3</option>
          <option selected>4</option>
          <option>5</option>
          <option>6</option>
        </select>
      </label>
    </div>

    <div class="hint">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: ‚Üê ‚Üë ‚Üí ‚Üì –∏–ª–∏ WASD. –ù–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–µ ‚Äî —Å–≤–∞–π–ø—ã. –ü–æ–±–µ–¥–∞ –Ω–∞ 2048 (–º–æ–∂–Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å).</div>

    <div class="board" id="board" style="--size:4">
      <div class="grid" id="grid"></div>
      <div class="tiles" id="tiles"></div>

      <div class="overlay" id="winOv">
        <div class="panel">
          <div class="title">üéâ 2048!</div>
          <div>–•–æ—á–µ—à—å –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∏–≥—Ä—É?</div>
          <div class="row">
            <button id="continue">Continue</button>
            <button id="newFromWin">New Game</button>
          </div>
        </div>
      </div>

      <div class="overlay" id="loseOv">
        <div class="panel">
          <div class="title">üí• –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞</div>
          <div class="row">
            <button id="restart">Try Again</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // DOM
  const boardEl = document.getElementById('board');
  const gridEl  = document.getElementById('grid');
  const tilesEl = document.getElementById('tiles');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const sizeSel = document.getElementById('sizeSel');
  const btnNew  = document.getElementById('newGame');
  const btnUndo = document.getElementById('undo');
  const winOv   = document.getElementById('winOv');
  const loseOv  = document.getElementById('loseOv');
  const btnContinue = document.getElementById('continue');
  const btnNewFromWin = document.getElementById('newFromWin');
  const btnRestart = document.getElementById('restart');

  // State
  let size = parseInt(localStorage.getItem('2048-size') || '4', 10);
  sizeSel.value = String(size);
  boardEl.style.setProperty('--size', size);

  let tiles = [];
  let idSeq = 1;
  let score = 0;
  let best = parseInt(localStorage.getItem('2048-best') || '0', 10);
  bestEl.textContent = best;

  let keepPlaying = false;
  let won = false;
  let over = false;

  let undoState = null;

  // Metrics
  const GAP = 12;
  let cell = 0, offX = 0, offY = 0, tilesRect;

  function computeMetrics() {
    tilesRect = tilesEl.getBoundingClientRect();
    const W = Math.max(tilesRect.width, 0);
    cell = (W - GAP * (size - 1)) / size;
    if (!isFinite(cell) || cell <= 0) {
      // fallback –ø–æ —à–∏—Ä–∏–Ω–µ —Å–∞–º–æ–≥–æ board
      const BW = Math.max(boardEl.clientWidth - GAP*2, 0);
      cell = (BW - GAP * (size - 1)) / size;
    }
    offX = 0; offY = 0;
  }

  function ensureLayout(cb) {
    // –ñ–¥–µ–º, –ø–æ–∫–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø–æ–ª—É—á–∏—Ç –Ω–µ–Ω—É–ª–µ–≤—É—é —à–∏—Ä–∏–Ω—É
    let tries = 0;
    const maxTries = 60; // ~1 —Å–µ–∫
    const tick = () => {
      computeMetrics();
      if (cell > 0 || tries >= maxTries) cb();
      else { tries++; requestAnimationFrame(tick); }
    };
    requestAnimationFrame(tick);
  }

  window.addEventListener('resize', () => { computeMetrics(); layoutTiles(); });

  // Utils
  const inBounds = (x,y) => x >= 0 && x < size && y >= 0 && y < size;

  function getGrid() {
    const g = Array.from({length:size}, () => Array(size).fill(null));
    for (const t of tiles) g[t.x][t.y] = t;
    return g;
  }
  function emptyCells() {
    const g = getGrid(), arr = [];
    for (let y=0;y<size;y++) for (let x=0;x<size;x++) if (!g[x][y]) arr.push({x,y});
    return arr;
  }
  function randEmptyCell() {
    const cells = emptyCells();
    if (!cells.length) return null;
    return cells[Math.floor(Math.random() * cells.length)];
  }

  // Rendering helpers
  function setupGridCells() {
    gridEl.innerHTML = '';
    for (let i=0;i<size*size;i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      gridEl.appendChild(cell);
    }
  }

  function posToTranslate(x, y, s=1) {
    const tx = offX + x * (cell + GAP);
    const ty = offY + y * (cell + GAP);
    return { tx, ty, s };
  }

  function tileStyle(value) {
    const bg = {
      2:'#eee4da', 4:'#ede0c8', 8:'#f2b179', 16:'#f59563', 32:'#f67c5f', 64:'#f65e3b',
      128:'#edcf72', 256:'#edcc61', 512:'#edc850', 1024:'#edc53f', 2048:'#edc22e'
    }[value] || '#3c3a32';
    const color = value <= 4 ? '#776e65' : '#f9f6f2';
    return { bg, color };
  }
  function valueFontSize(v) {
    if (v < 100) return 0.42;
    if (v < 1000) return 0.38;
    if (v < 10000) return 0.33;
    return 0.30;
  }

  function spawnTileEl(t) {
    const el = document.createElement('div');
    el.className = 'tile';
    el.dataset.id = t.id;
    const { bg, color } = tileStyle(t.value);
    el.style.background = bg;
    el.style.color = color;
    el.textContent = t.value;
    tilesEl.appendChild(el);
    updateTileEl(t);
  }
  function getTileEl(t) { return tilesEl.querySelector(`.tile[data-id="${t.id}"]`); }

  function updateTileEl(t, bump=false) {
    const el = getTileEl(t);
    if (!el) return;
    el.style.width = el.style.height = cell + 'px';
    const { tx, ty } = posToTranslate(t.x, t.y, t.scale || 1);
    el.style.setProperty('--tx', tx+'px');
    el.style.setProperty('--ty', ty+'px');
    el.style.setProperty('--s', (t.scale || 1));
    // text / colors
    const { bg, color } = tileStyle(t.value);
    el.style.background = bg;
    el.style.color = color;
    el.style.fontSize = (valueFontSize(t.value) * cell) + 'px';
    el.textContent = t.value;
    if (bump) {
      el.classList.remove('bump'); void el.offsetWidth; el.classList.add('bump');
    }
  }
  function removeTileEl(t) {
    const el = getTileEl(t);
    if (el && el.parentNode) el.parentNode.removeChild(el);
  }
  function layoutTiles() {
    for (const t of tiles) updateTileEl(t);
  }

  // Score
  function updateScore(delta, reset=false) {
    if (reset) score = 0; else score += delta;
    scoreEl.textContent = score;
    if (score > best) {
      best = score; bestEl.textContent = best;
      try { localStorage.setItem('2048-best', String(best)); } catch {}
    }
  }

  // Game flow
  function resetGrid() {
    tiles = []; idSeq = 1;
    score = 0; won = false; keepPlaying = false; over = false;
    updateScore(0, true);
    tilesEl.innerHTML = '';
    winOv.classList.remove('show'); loseOv.classList.remove('show');
    setupGridCells();
    computeMetrics();

    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä—Ç–æ–≤—ã—Ö –ø–ª–∏—Ç–æ–∫ –ø–æ—Å–ª–µ —É–≤–µ—Ä–µ–Ω–Ω–æ–π –≤—ë—Ä—Å—Ç–∫–∏
    addRandomTile(true);
    addRandomTile(true);
    saveUndo();
  }

  function addRandomTile(spawn=false) {
    const spot = randEmptyCell();
    if (!spot) return false;
    const val = Math.random() < 0.9 ? 2 : 4;
    const t = { id: idSeq++, x: spot.x, y: spot.y, value: val, scale: spawn ? 0.1 : 1 };
    tiles.push(t);
    spawnTileEl(t);
    if (spawn) requestAnimationFrame(() => { t.scale = 1; updateTileEl(t); });
    return true;
  }

  // Movement
  const VECTORS = {
    left:{x:-1,y:0}, right:{x:1,y:0}, up:{x:0,y:-1}, down:{x:0,y:1}
  };
  function buildTraversals(vector) {
    const xs = [...Array(size).keys()];
    const ys = [...Array(size).keys()];
    if (vector.x === 1) xs.reverse();
    if (vector.y === 1) ys.reverse();
    return { xs, ys };
  }
  function findFarthest(cell, vector, grid) {
    let prev, x = cell.x, y = cell.y;
    do { prev = {x,y}; x += vector.x; y += vector.y; }
    while (inBounds(x,y) && !grid[x][y]);
    return { farthest: prev, next: {x,y} };
  }
  function canMove() {
    const g = getGrid();
    for (let y=0;y<size;y++) for (let x=0;x<size;x++) if (!g[x][y]) return true;
    for (let y=0;y<size;y++) for (let x=0;x<size;x++) {
      const t = g[x][y]; if (!t) continue;
      for (const v of Object.values(VECTORS)) {
        const nx=x+v.x, ny=y+v.y;
        if (!inBounds(nx,ny)) continue;
        const n=g[nx][ny];
        if (n && n.value===t.value) return true;
      }
    }
    return false;
  }

  function move(dir) {
    if (over) return;
    const vector = VECTORS[dir];
    const { xs, ys } = buildTraversals(vector);
    const grid = getGrid();
    let moved = false;

    for (const t of tiles) t.merged = false;

    for (const y of ys) for (const x of xs) {
      const t = grid[x][y];
      if (!t) continue;

      const start = { x, y };
      const { farthest, next } = findFarthest(start, vector, grid);
      const nextTile = inBounds(next.x, next.y) ? grid[next.x][next.y] : null;

      if (nextTile && nextTile.value === t.value && !nextTile.merged) {
        grid[t.x][t.y] = null;
        t.x = next.x; t.y = next.y;
        t.value *= 2; t.merged = true;
        grid[next.x][next.y] = t;

        const idx = tiles.indexOf(nextTile);
        if (idx >= 0) { tiles.splice(idx, 1); removeTileEl(nextTile); }

        updateTileEl(t, true);
        updateScore(t.value);
        moved = true;

        if (t.value === 2048 && !keepPlaying) won = true;
      } else {
        if (farthest.x !== t.x || farthest.y !== t.y) {
          grid[t.x][t.y] = null;
          t.x = farthest.x; t.y = farthest.y;
          grid[t.x][t.y] = t;
          updateTileEl(t);
          moved = true;
        }
      }
    }

    if (moved) {
      setTimeout(() => {
        addRandomTile(true);
        saveUndo();
        if (!canMove()) { over = true; loseOv.classList.add('show'); }
        else if (won && !keepPlaying) { winOv.classList.add('show'); }
      }, 120);
    }
  }

  // Undo
  function saveUndo() {
    undoState = {
      tiles: tiles.map(t => ({...t})),
      score, won, keepPlaying, over
    };
  }
  function doUndo() {
    if (!undoState) return;
    tiles = undoState.tiles.map(t => ({...t}));
    score = undoState.score; scoreEl.textContent = score;
    won = undoState.won; keepPlaying = undoState.keepPlaying; over = undoState.over;
    tilesEl.innerHTML = '';
    computeMetrics();
    for (const t of tiles) spawnTileEl(t);
    layoutTiles();
    winOv.classList.toggle('show', won && !keepPlaying);
    loseOv.classList.toggle('show', over);
  }

  // Input
  document.addEventListener('keydown', (e) => {
    const c = e.code;
    if (winOv.classList.contains('show') || loseOv.classList.contains('show')) {
      if (c === 'Enter' || c === 'Space') {
        if (winOv.classList.contains('show')) { keepPlaying = true; winOv.classList.remove('show'); }
        else restart();
      }
      return;
    }
    if (c === 'ArrowLeft' || c === 'KeyA') { e.preventDefault(); move('left'); }
    if (c === 'ArrowRight'|| c === 'KeyD') { e.preventDefault(); move('right'); }
    if (c === 'ArrowUp'   || c === 'KeyW') { e.preventDefault(); move('up'); }
    if (c === 'ArrowDown' || c === 'KeyS') { e.preventDefault(); move('down'); }
    if (c === 'KeyU') { e.preventDefault(); doUndo(); }
    if (c === 'KeyN' || c === 'KeyR') { e.preventDefault(); restart(); }
  });

  // Touch swipes
  let startX=0, startY=0, startT=0;
  boardEl.addEventListener('touchstart', (e) => {
    const t = e.changedTouches[0];
    startX = t.clientX; startY = t.clientY; startT = performance.now();
  }, {passive:true});
  boardEl.addEventListener('touchend', (e) => {
    const t = e.changedTouches[0];
    const dx = t.clientX - startX;
    const dy = t.clientY - startY;
    const dt = performance.now() - startT;
    const thr = 24;
    if (dt > 800) return;
    if (Math.abs(dx) < thr && Math.abs(dy) < thr) return;
    if (Math.abs(dx) > Math.abs(dy)) move(dx > 0 ? 'right' : 'left');
    else move(dy > 0 ? 'down' : 'up');
  }, {passive:true});

  // Buttons
  btnNew.addEventListener('click', restart);
  btnUndo.addEventListener('click', doUndo);
  sizeSel.addEventListener('change', () => {
    size = parseInt(sizeSel.value, 10);
    try { localStorage.setItem('2048-size', String(size)); } catch {}
    boardEl.style.setProperty('--size', size);
    restart();
  });
  btnContinue.addEventListener('click', () => { keepPlaying = true; winOv.classList.remove('show'); });
  btnNewFromWin.addEventListener('click', restart);
  btnRestart.addEventListener('click', restart);

  function restart() {
    winOv.classList.remove('show'); loseOv.classList.remove('show');
    keepPlaying = false; won = false; over = false;
    setupGridCells();
    ensureLayout(resetGrid);
  }

  // Boot ‚Äî –∂–¥—ë–º, –ø–æ–∫–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä ¬´–ø—Ä–æ—Å–Ω—ë—Ç—Å—è¬ª, –∑–∞—Ç–µ–º —Å—Ç–∞—Ä—Ç—É–µ–º
  function boot() {
    setupGridCells();
    ensureLayout(resetGrid);
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', boot);
  } else {
    boot();
  }
})();
</script>
</body>
</html>
